@unstable(feature = tls)
interface tls {
    @unstable(feature = tls)
    use wasi:io/streams@0.2.0.{input-stream, output-stream};
    @unstable(feature = tls)
    use wasi:io/poll@0.2.0.{pollable};

    @unstable(feature = tls)
    resource client-connection {
        @unstable(feature = tls)
        constructor(input: input-stream, output: output-stream);
        @unstable(feature = tls)
        connect: func(server-name: string) -> result<client-handshake>;
        /// The server name that was provided to `connect`.
        @unstable(feature = tls)
        server-name: func() -> option<string>;

        /// The negotiated ALPN ID, if any.
        ///
        /// Returns `none` when:
        /// - the client did not advertise any ALPN IDs, or:
        /// - there was no intersection between the IDs advertised by the client
        ///   and the IDs supported by the server. 
        @unstable(feature = tls)
        alpn-id: func() -> option<alpn-id>;

        /// The client's identity advertised to the server, if any.
        /// This will be one of the identities passed to
        /// `client-identity-request::respond`.
        ///
        /// Returns `none` when:
        /// - the server did not request a client certificate,
        /// - the server did request a client certificate, but there was no match
        ///   with the configured identities.
        @unstable(feature = tls)
        client-identity: func() -> option<private-identity>;

        /// The verified certificate of the server.
        @unstable(feature = tls)
        server-identity: func() -> option<public-identity>;

        /// The negotiated TLS protocol version.
        @unstable(feature = tls)
        protocol-version: func() -> option<protocol-version>;

        /// The negotiated cipher suite
        @unstable(feature = tls)
        cipher-suite: func() -> option<cipher-suite>;
    }

    @unstable(feature = tls)
    resource client-handshake {
        @unstable(feature = tls)
        finish: static func(this: client-handshake) -> future-streams;
    }

    @unstable(feature = tls)
    resource future-streams {
        @unstable(feature = tls)
        subscribe: func() -> pollable;
        @unstable(feature = tls)
        get: func() -> option<result<result<tuple<input-stream, output-stream>>>>;
    }

    // TODO: this belongs in `wasi:io/streams` but we put it here temporarily to
    // make implementation easier (i.e. avoid forking `wasmtime_wasi`).
    @unstable(feature = tls)
    make-pipe: func() -> tuple<input-stream, output-stream>;
}

