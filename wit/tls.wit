@unstable(feature = tls)
interface tls {
    @unstable(feature = tls)
    use wasi:io/streams@0.2.0.{input-stream, output-stream};
    @unstable(feature = tls)
    use wasi:io/poll@0.2.0.{pollable};

    /// TLS protocol version.
    ///
    /// At the time of writing, these are the existing TLS versions:
    /// - 0x0200: SSLv2 (Deprecated)
    /// - 0x0300: SSLv3 (Deprecated)
    /// - 0x0301: TLSv1.0 (Deprecated)
    /// - 0x0302: TLSv1.1 (Deprecated)
    /// - 0x0303: TLSv1.2
    /// - 0x0304: TLSv1.3
    ///
    /// TODO: Want to use regular WIT `enum` type, but then adding a new protocol is backwards incompatible.
    type protocol-version = u16;

    /// Application-Layer Protocol Negotiation (ALPN) protocol ID.
    ///
    /// ALPN IDs are between 1 and 255 bytes long. Typically, they represent the
    /// binary encoding of an ASCII string (e.g. `[0x68 0x32]` for `"h2"`),
    /// though this is not required.
    type alpn-id = list<u8>;

    /// TLS Cipher suite.
    ///
    /// These are maintained by IANA. Examples:
    /// - 0x1301: TLS_AES_128_GCM_SHA256
    /// - 0x1302: TLS_AES_256_GCM_SHA384
    /// - 0xC030: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    /// - 0xC02B: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    /// - etc.
    /// 
    /// See: <https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4>
    type cipher-suite = u16;

    /// A X509 certificate chain; starting with the end-entity's certificate
    /// followed by 0 or more intermediate certificates.
    resource public-identity {
        export-X509-chain: func() -> list<list<u8>>;
    }

    /// The combination of a private key with its public certificate(s).
    /// The private key data can not be exported.
    resource private-identity {
        /// TODO: find a way to "preopen" these private-identity resources, so that the sensitive private key data never has to flow through the guest.
        /// TODO: specify which exact binary format
        //parse: static func(private-key: list<u8>, x509-chain: list<list<u8>>) -> result<private-identity>;

        public-identity: func() -> public-identity;
    }

    @unstable(feature = tls)
    resource client-connection {
        @unstable(feature = tls)
        constructor(input: input-stream, output: output-stream);
        @unstable(feature = tls)
        connect: func(server-name: string) -> result<client-handshake>;
        /// The server name that was provided to `connect`.
        @unstable(feature = tls)
        server-name: func() -> option<string>;

        /// The negotiated ALPN ID, if any.
        ///
        /// Returns `none` when:
        /// - the client did not advertise any ALPN IDs, or:
        /// - there was no intersection between the IDs advertised by the client
        ///   and the IDs supported by the server. 
        @unstable(feature = tls)
        alpn-id: func() -> option<alpn-id>;

        /// The client's identity advertised to the server, if any.
        /// This will be one of the identities passed to
        /// `client-identity-request::respond`.
        ///
        /// Returns `none` when:
        /// - the server did not request a client certificate,
        /// - the server did request a client certificate, but there was no match
        ///   with the configured identities.
        @unstable(feature = tls)
        client-identity: func() -> option<private-identity>;

        /// The verified certificate of the server.
        @unstable(feature = tls)
        server-identity: func() -> option<public-identity>;

        /// The negotiated TLS protocol version.
        @unstable(feature = tls)
        protocol-version: func() -> option<protocol-version>;

        /// The negotiated cipher suite
        @unstable(feature = tls)
        cipher-suite: func() -> option<cipher-suite>;
    }

    @unstable(feature = tls)
    resource client-handshake {
        @unstable(feature = tls)
        finish: static func(this: client-handshake) -> future-streams;
    }

    @unstable(feature = tls)
    resource future-streams {
        @unstable(feature = tls)
        subscribe: func() -> pollable;
        @unstable(feature = tls)
        get: func() -> option<result<result<tuple<input-stream, output-stream>>>>;
    }

    // TODO: this belongs in `wasi:io/streams` but we put it here temporarily to
    // make implementation easier (i.e. avoid forking `wasmtime_wasi`).
    @unstable(feature = tls)
    make-pipe: func() -> tuple<input-stream, output-stream>;
}

